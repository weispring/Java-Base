ArrayList:
动态数据，默认容量10，扩若因子1.5倍，add、remove、clear 会导致modCount++;

Vector:
(01) Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。
(02) 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 >0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。
(03) Enumeration的循环方式

Stack 栈，继承Vector

HashMap
动态数组 + 链表

EnumMap
key 值集合固定并且类型固定，长度固定，每个元素都是一个值，不存在链表结构，本质定长数组
程序内部能够区分没有映射和映射为null的情况，但是两者最终的返回结果都是一样的，都是null
无modCount校验,它们不会抛出 ConcurrentModificationException
不允许使用 null 键。试图插入 null 键将抛出 NullPointerException。但是，试图测试是否出现 null 键或移除 null 键将不会抛出异常。允许使用 null 值。
put、get方法：
put方法通过key的ordinal将值存储到对应的地方，get方法则根据key的ordinal获取对应的值。

BitSet
Java BitSet可以按位存储，计算机中一个字节(byte)占8位(bit)；
而BitSet是位操作的对象，值只有0或1（即true 和 false），内部维护一个long数组，初始化只有一个long segement，所以BitSet最小的size是64；随着存储的元素越来越多，BitSet内部会自动扩充，一次扩大一倍，最终内部是由N个long segement 来存储；
默认情况下，BitSet所有位都是0即false；

BitSet的应用场景
海量数据去重、排序、压缩存储
BitSet的基本操作
and（与）、or（或）、xor（异或）
BitSet的优缺点
优点：
按位存储，内存占用空间小
丰富的api操作
缺点：
线程不安全
BitSet内部动态扩展long型数组，若数据稀疏会占用较大的内存
BitSet为什么选择long型数组作为内部存储结构
JDK选择long数组作为BitSet的内部存储结构是出于性能的考虑，在and和or的时候减少循环次数，提高性能；